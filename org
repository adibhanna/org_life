#!/bin/zsh

# org - Simple file organization CLI
# Usage: org <command> [args]

set -e
setopt KSH_ARRAYS 2>/dev/null || true

# Use full paths for reliability in non-interactive zsh
FIND=/usr/bin/find
WC=/usr/bin/wc
TR=/usr/bin/tr
DU=/usr/bin/du
HEAD=/usr/bin/head
FILE=/usr/bin/file
GREP=/usr/bin/grep
BASENAME=/usr/bin/basename
MKDIR=/bin/mkdir
MV=/bin/mv
CP=/bin/cp
RM=/bin/rm
OPEN=/usr/bin/open
SED=/usr/bin/sed
FZF=/opt/homebrew/bin/fzf
RG=/opt/homebrew/bin/rg

# Config file location
CONFIG_DIR="$HOME/.config/orglife"
CONFIG_FILE="$CONFIG_DIR/org.yaml"
BASE_DIR=""

# Parse base directory from yaml
load_base_dir() {
    if [ ! -f "$CONFIG_FILE" ]; then
        return 1
    fi

    local line
    while IFS= read -r line; do
        if [[ "$line" =~ ^base: ]]; then
            BASE_DIR="${line#base:}"
            BASE_DIR=$(echo "$BASE_DIR" | $SED 's/^ *//' | $SED 's/ *$//')
            BASE_DIR="${BASE_DIR/#\~/$HOME}"
            return 0
        fi
    done < "$CONFIG_FILE"
    return 1
}

# Load base dir on startup
load_base_dir || true

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

# Load destinations from yaml
load_destinations() {
    declare -gA DESTINATIONS
    declare -gA DESCRIPTIONS

    if [ ! -f "$CONFIG_FILE" ]; then
        return 1
    fi

    local key rest path desc

    # Parse yaml (format: key: path | description)
    while IFS= read -r line; do
        # Skip empty lines, comments, and base directive
        [[ -z "$line" || "$line" =~ ^# || "$line" =~ ^base: ]] && continue

        # Extract key (before colon)
        key="${line%%:*}"
        key=$(echo "$key" | $TR -d ' ')
        [[ -z "$key" ]] && continue

        # Extract value (after colon)
        rest="${line#*:}"
        rest=$(echo "$rest" | $SED 's/^ *//')

        # Split by pipe for path and description
        path="${rest%%|*}"
        path=$(echo "$path" | $SED 's/ *$//')

        desc=""
        if [[ "$rest" == *"|"* ]]; then
            desc="${rest#*|}"
            desc=$(echo "$desc" | $SED 's/^ *//')
        fi

        [ -n "$key" ] && [ -n "$path" ] && DESTINATIONS[$key]="$path"
        [ -n "$key" ] && [ -n "$desc" ] && DESCRIPTIONS[$key]="$desc"
    done < "$CONFIG_FILE"
}

# Check if config exists for commands that need it
require_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${YELLOW}No config found.${NC} Run ${CYAN}org setup${NC} first."
        exit 1
    fi
    # Reload base and destinations
    load_base_dir
    load_destinations
}

# Load destinations on startup if config exists
load_destinations || true

# Get sorted destination keys
get_dest_keys() {
    printf '%s\n' "${(k)DESTINATIONS[@]}" | /usr/bin/sort
}

# Fuzzy match destination
match_dest() {
    local input="$1"
    local exact=""
    local partial=""

    for key in "${(k)DESTINATIONS[@]}"; do
        if [[ "$key" == "$input" ]]; then
            exact="$key"
            break
        elif [[ "$key" == *"$input"* ]]; then
            partial="$key"
        fi
    done

    if [ -n "$exact" ]; then
        echo "$exact"
    elif [ -n "$partial" ]; then
        echo "$partial"
    fi
}

# Show help
show_help() {
    echo -e "${BOLD}org${NC} - Simple file organization CLI"
    echo

    # Not configured - show minimal help
    if [ -z "$BASE_DIR" ]; then
        echo -e "Run ${CYAN}org setup${NC} to get started"
        echo
        return
    fi

    # Fully configured - show full help
    echo -e "${BOLD}USAGE:${NC}"
    echo "  org <command> [args]"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "  ${CYAN}mv${NC} <file> <dest>    Move file to destination"
    echo -e "  ${CYAN}cp${NC} <file> <dest>    Copy file to destination"
    echo -e "  ${CYAN}archive${NC} <file>      Archive file with date prefix"
    echo -e "  ${CYAN}archive-project${NC}    Archive entire project"
    echo -e "  ${CYAN}rm${NC} <alias>          Remove project and config entry"
    echo -e "  ${CYAN}ls${NC}                  List all destinations"
    echo -e "  ${CYAN}cd${NC} <dest>           Print path (use: cd \$(org cd work))"
    echo -e "  ${CYAN}open${NC} <dest>         Open destination in Finder"
    echo -e "  ${CYAN}inbox${NC}               Process inbox interactively"
    echo -e "  ${CYAN}status${NC}              Show organization status"
    echo -e "  ${CYAN}find${NC} [term]         Search files with fzf (rg for content)"
    echo -e "  ${CYAN}code${NC}                Open code project in editor"
    echo -e "  ${CYAN}add${NC} <path> [-t tpl] Add new project with template"
    echo -e "  ${CYAN}template${NC}            Manage project templates"
    echo -e "  ${CYAN}sync${NC}                Sync config with directory structure"
    echo -e "  ${CYAN}edit${NC}                Edit config in \$EDITOR"
    echo -e "  ${CYAN}create${NC}              Create directories from config"
    echo
    echo -e "${BOLD}DESTINATIONS:${NC}"
    # Calculate max alias width
    local max_alias=5
    local key
    for key in $(get_dest_keys); do
        [ ${#key} -gt $max_alias ] && max_alias=${#key}
    done
    max_alias=$((max_alias + 2))

    for key in $(get_dest_keys); do
        printf "  ${BLUE}%-${max_alias}s${NC} %s\n" "$key" "${DESTINATIONS[$key]}"
    done
    echo
    echo -e "${DIM}Config: $CONFIG_FILE${NC}"
}

# Move or copy file to destination
move_file() {
    require_config
    local action="$1"  # mv or cp
    local file="$2"
    local dest_alias="$3"

    if [ -z "$file" ] || [ -z "$dest_alias" ]; then
        echo -e "${RED}Usage: org $action <file> <destination>${NC}"
        echo -e "Run ${CYAN}org ls${NC} to see available destinations"
        exit 1
    fi

    if [ ! -e "$file" ]; then
        echo -e "${RED}Error: '$file' not found${NC}"
        exit 1
    fi

    # Match destination
    local matched=$(match_dest "$dest_alias")
    if [ -z "$matched" ]; then
        echo -e "${RED}Unknown destination: $dest_alias${NC}"
        echo -e "Run ${CYAN}org ls${NC} to see available destinations"
        exit 1
    fi

    local dest_path="$BASE_DIR/${DESTINATIONS[$matched]}"
    $MKDIR -p "$dest_path"

    # Get filename
    local filename=$($BASENAME "$file")
    local target="$dest_path/$filename"

    # Check for existing file
    if [ -e "$target" ]; then
        echo -e "${YELLOW}File exists: $target${NC}"
        echo -n "Overwrite? (y/N) "
        read -k 1 REPLY
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
    fi

    if [ "$action" = "mv" ]; then
        $MV "$file" "$target"
        echo -e "${GREEN}Moved:${NC} $filename -> ${DESTINATIONS[$matched]}/"
    else
        $CP -r "$file" "$target"
        echo -e "${GREEN}Copied:${NC} $filename -> ${DESTINATIONS[$matched]}/"
    fi
}

# Archive file with date prefix into year folder
archive_file() {
    require_config
    local file="$1"
    local archive_type="${2:-personal}"  # personal or work

    if [ -z "$file" ]; then
        echo -e "${BOLD}Usage:${NC} org archive <file> [work]"
        echo
        echo -e "Archives file to ${CYAN}Archive/YYYY/YYYY-MM-DD_filename${NC}"
        echo
        echo -e "Examples:"
        echo -e "  org archive invoice.pdf          # -> Personal/Archive/2025/2025-12-10_invoice.pdf"
        echo -e "  org archive report.pdf work      # -> Work/.../Archive/2025/2025-12-10_report.pdf"
        exit 1
    fi

    if [ ! -e "$file" ]; then
        echo -e "${RED}Error: '$file' not found${NC}"
        exit 1
    fi

    # Get date components
    local year=$(date +%Y)
    local date_prefix=$(date +%Y-%m-%d)

    # Determine archive path
    local archive_base=""
    if [ "$archive_type" = "work" ] || [ "$archive_type" = "w" ]; then
        # Find work archive path
        if [ -n "${DESTINATIONS[warchive]}" ]; then
            archive_base="$BASE_DIR/${DESTINATIONS[warchive]}"
        else
            echo -e "${RED}No work archive configured${NC}"
            exit 1
        fi
    else
        # Personal archive
        if [ -n "${DESTINATIONS[archive]}" ]; then
            archive_base="$BASE_DIR/${DESTINATIONS[archive]}"
        else
            echo -e "${RED}No archive configured${NC}"
            exit 1
        fi
    fi

    # Create year subfolder
    local dest_dir="$archive_base/$year"
    $MKDIR -p "$dest_dir"

    # Build target filename with date prefix
    local filename=$($BASENAME "$file")
    local target="$dest_dir/${date_prefix}_${filename}"

    # Check for existing file
    if [ -e "$target" ]; then
        echo -e "${YELLOW}File exists: $target${NC}"
        echo -n "Overwrite? (y/N) "
        read -k 1 REPLY
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
    fi

    $MV "$file" "$target"

    # Show relative path for cleaner output
    local rel_path="${target#$BASE_DIR/}"
    echo -e "${GREEN}Archived:${NC} $filename -> $rel_path"
}

# List destinations
list_destinations() {
    require_config

    # Calculate max widths
    local max_alias=5 max_path=4
    local key path

    for key in $(get_dest_keys); do
        path="${DESTINATIONS[$key]}"
        [ ${#key} -gt $max_alias ] && max_alias=${#key}
        [ ${#path} -gt $max_path ] && max_path=${#path}
    done

    # Add padding
    max_alias=$((max_alias + 2))
    max_path=$((max_path + 2))

    # Header
    printf "${BOLD}%-${max_alias}s %-${max_path}s %s${NC}\n" "ALIAS" "PATH" "DESCRIPTION"
    local line_len=$((max_alias + max_path + 30))
    printf "${DIM}%${line_len}s${NC}\n" | $TR ' ' 'â”€'

    # Rows
    local desc
    for key in $(get_dest_keys); do
        path="${DESTINATIONS[$key]}"
        desc="${DESCRIPTIONS[$key]:-}"
        printf "${BLUE}%-${max_alias}s${NC} %-${max_path}s ${DIM}%s${NC}\n" "$key" "$path" "$desc"
    done

    echo
    echo -e "${DIM}Base: $BASE_DIR${NC}"
}

# Print path for cd
print_path() {
    require_config
    local dest_alias="$1"

    if [ -z "$dest_alias" ]; then
        echo "$BASE_DIR"
        return
    fi

    local matched=$(match_dest "$dest_alias")
    if [ -z "$matched" ]; then
        echo "$BASE_DIR"
        return
    fi

    echo "$BASE_DIR/${DESTINATIONS[$matched]}"
}

# Open in Finder
open_dest() {
    require_config
    local dest_alias="${1:-}"
    local path

    if [ -z "$dest_alias" ]; then
        path="$BASE_DIR"
    else
        local matched=$(match_dest "$dest_alias")
        if [ -z "$matched" ]; then
            echo -e "${RED}Unknown destination: $dest_alias${NC}"
            exit 1
        fi
        path="$BASE_DIR/${DESTINATIONS[$matched]}"
    fi

    $MKDIR -p "$path"
    $OPEN "$path"
    echo -e "${GREEN}Opened:${NC} $path"
}

# Process inbox
process_inbox() {
    require_config
    local inbox_dir="$BASE_DIR/Inbox"

    if [ ! -d "$inbox_dir" ]; then
        echo -e "${YELLOW}Inbox not found. Run ${CYAN}org init${NC} first.${NC}"
        exit 1
    fi

    # Get files
    local files=()
    while IFS= read -r -d '' file; do
        files+=("$file")
    done < <($FIND "$inbox_dir" -type f -not -name ".*" -print0 2>/dev/null)

    local count=${#files[@]}

    if [ "$count" -eq 0 ]; then
        echo -e "${GREEN}Inbox is empty!${NC}"
        exit 0
    fi

    echo -e "${BOLD}Inbox: $count file(s) to process${NC}"
    echo

    local dest_keys=($(get_dest_keys))

    for file in "${files[@]}"; do
        local filename=$($BASENAME "$file")
        local filesize=$($DU -h "$file" 2>/dev/null | cut -f1)
        local filetype=$($FILE -b "$file" 2>/dev/null | cut -d',' -f1)

        echo -e "${BOLD}File:${NC} ${CYAN}$filename${NC}"
        echo -e "${DIM}Size: $filesize | Type: $filetype${NC}"

        # Preview text files
        if $FILE "$file" | $GREP -q "text"; then
            echo -e "${DIM}Preview:${NC}"
            $HEAD -n 3 "$file" 2>/dev/null | sed 's/^/  /'
        fi
        echo

        echo -e "${BOLD}Move to:${NC}"
        local i=1
        for key in "${dest_keys[@]}"; do
            printf "  ${BLUE}%2d)${NC} %-10s %s\n" "$i" "$key" "${DESTINATIONS[$key]}"
            ((i++))
        done
        echo -e "  ${BLUE} d)${NC} Delete"
        echo -e "  ${BLUE} s)${NC} Skip"
        echo -e "  ${BLUE} q)${NC} Quit"
        echo

        echo -n "Choice: "
        read choice

        case "$choice" in
            [0-9]*)
                if [ "$choice" -ge 1 ] && [ "$choice" -le "${#dest_keys[@]}" ]; then
                    local dest_key="${dest_keys[$((choice-1))]}"
                    local dest_path="$BASE_DIR/${DESTINATIONS[$dest_key]}"
                    $MKDIR -p "$dest_path"
                    $MV "$file" "$dest_path/"
                    echo -e "${GREEN}Moved to ${dest_key}${NC}"
                else
                    echo -e "${YELLOW}Invalid choice, skipping${NC}"
                fi
                ;;
            d|D)
                echo -n "Delete '$filename'? (y/N) "
                read -k 1 REPLY
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    $RM "$file"
                    echo -e "${RED}Deleted${NC}"
                fi
                ;;
            s|S)
                echo -e "${YELLOW}Skipped${NC}"
                ;;
            q|Q)
                echo "Bye!"
                exit 0
                ;;
            *)
                echo -e "${YELLOW}Skipped${NC}"
                ;;
        esac
        echo
    done

    # Final count
    local remaining=$($FIND "$inbox_dir" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
    echo -e "${GREEN}Done!${NC} ${remaining} files remaining in inbox."
}

# Show status
show_status() {
    require_config
    echo -e "${BOLD}Organization Status${NC}"
    echo

    local inbox_count=0
    local total_size key cat_path cat_count cat_size

    # Inbox count
    if [ -d "$BASE_DIR/Inbox" ]; then
        inbox_count=$($FIND "$BASE_DIR/Inbox" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
    fi

    if [ "$inbox_count" -gt 0 ]; then
        echo -e "${YELLOW}Inbox:${NC} $inbox_count files need sorting"
    else
        echo -e "${GREEN}Inbox:${NC} Empty"
    fi

    # Total size
    if [ -d "$BASE_DIR" ]; then
        total_size=$($DU -sh "$BASE_DIR" 2>/dev/null | cut -f1)
        echo -e "${CYAN}Total:${NC} $total_size"
    fi

    # Recent files
    echo
    echo -e "${BOLD}Recently added:${NC}"
    $FIND "$BASE_DIR" -type f -not -name ".*" -not -path "*/.git/*" -mtime -1 2>/dev/null | $HEAD -5 | while read f; do
        echo "  $($BASENAME "$f")"
    done

    # Category breakdown
    echo
    echo -e "${BOLD}Categories:${NC}"
    for key in work projects finance docs media learn; do
        if [ -n "${DESTINATIONS[$key]}" ]; then
            cat_path="$BASE_DIR/${DESTINATIONS[$key]}"
            if [ -d "$cat_path" ]; then
                cat_count=$($FIND "$cat_path" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
                cat_size=$($DU -sh "$cat_path" 2>/dev/null | cut -f1)
                printf "  %-12s %4d files  %s\n" "$key" "$cat_count" "$cat_size"
            fi
        fi
    done
}

# Create yaml config file with base directory
create_config() {
    local base_path="$1"
    local mode="$2"  # both, work, personal
    local work_name="$3"  # company/project name for work
    $MKDIR -p "$CONFIG_DIR"

    cat > "$CONFIG_FILE" << EOF
# org.yaml - File organization config
# Edit with: org edit

base: $base_path

# Format: alias: path | description
EOF

    # Add work section
    if [[ "$mode" == "both" || "$mode" == "work" ]]; then
        cat >> "$CONFIG_FILE" << EOF

# Work - $work_name
wcode: Work/$work_name/Code | Code and repos
wdocs: Work/$work_name/Docs | Documents
winbox: Work/$work_name/Inbox | Files to sort
warchive: Work/$work_name/Archive | Archived files
EOF
    fi

    # Add personal section
    if [[ "$mode" == "both" || "$mode" == "personal" ]]; then
        cat >> "$CONFIG_FILE" << 'EOF'

# Personal
docs: Personal/Docs | Personal documents
finance: Personal/Finance | Financial documents
receipts: Personal/Finance/Receipts | Purchase receipts
taxes: Personal/Finance/Taxes | Tax documents
identity: Personal/Docs/Identity | ID, passport, licenses
legal: Personal/Docs/Legal | Contracts and legal docs
media: Personal/Media | Media files
photos: Personal/Media/Photos | Photos and images
screenshots: Personal/Media/Screenshots | Screenshots
videos: Personal/Media/Videos | Video files
learn: Personal/Learning | Learning materials
courses: Personal/Learning/Courses | Online courses
books: Personal/Learning/Books | Ebooks and PDFs
notes: Personal/Notes | Notes and journals
inbox: Personal/Inbox | Personal files to sort
archive: Personal/Archive | Archived personal files
EOF
    fi

    echo -e "${GREEN}Created:${NC} $CONFIG_FILE"
}

# Setup - create config with base directory
setup() {
    if [ -f "$CONFIG_FILE" ]; then
        echo -e "${YELLOW}Config exists:${NC} $CONFIG_FILE"
        echo -e "Edit with: ${CYAN}org edit${NC}"
        return
    fi

    echo -e "${BOLD}org setup${NC}"
    echo

    # Ask for base directory
    echo -n "Base directory [~/Life]: "
    read base_path
    base_path="${base_path:-~/Life}"
    base_path="${base_path/#\~/$HOME}"

    # Ask for mode
    echo
    echo "What do you want to organize?"
    echo -e "  ${CYAN}1${NC}) Work and Personal (default)"
    echo -e "  ${CYAN}2${NC}) Work only"
    echo -e "  ${CYAN}3${NC}) Personal only"
    echo -n "Choice [1]: "
    read mode_choice

    local mode="both"
    case "$mode_choice" in
        2) mode="work" ;;
        3) mode="personal" ;;
        *) mode="both" ;;
    esac

    # Ask for work name if work mode
    local work_name=""
    if [[ "$mode" == "both" || "$mode" == "work" ]]; then
        echo
        echo -n "Company/project name: "
        read work_name
        if [ -z "$work_name" ]; then
            echo -e "${RED}Company/project name required${NC}"
            exit 1
        fi
    fi

    create_config "$base_path" "$mode" "$work_name"

    # Reload
    load_base_dir
    load_destinations

    # Show preview
    echo
    echo -e "${BOLD}Directory structure:${NC}"
    for key in $(get_dest_keys); do
        echo -e "  ${DIM}${DESTINATIONS[$key]}${NC}"
    done

    echo
    echo -n "Create these directories? [Y/n]: "
    read use_defaults

    if [[ "$use_defaults" =~ ^[Nn] ]]; then
        echo
        echo -e "Edit config with: ${CYAN}org edit${NC}"
        echo -e "Then run: ${CYAN}org create${NC}"
    else
        echo
        create_dirs
    fi
}

# Edit config in $EDITOR
edit_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${YELLOW}No config found.${NC} Run ${CYAN}org setup${NC} first."
        exit 1
    fi

    local editor="${EDITOR:-vim}"
    $editor "$CONFIG_FILE"

    # Reload after edit
    load_base_dir
    load_destinations
}

# Create directories from config
create_dirs() {
    require_config

    echo -e "${BOLD}Creating directories in $BASE_DIR${NC}"
    echo

    local key dir_path
    for key in $(get_dest_keys); do
        dir_path="$BASE_DIR/${DESTINATIONS[$key]}"
        if [ ! -d "$dir_path" ]; then
            $MKDIR -p "$dir_path"
            echo -e "${GREEN}Created:${NC} ${DESTINATIONS[$key]}"
        else
            echo -e "${DIM}Exists:${NC} ${DESTINATIONS[$key]}"
        fi
    done

    echo
    echo -e "${GREEN}Done!${NC} Base: $BASE_DIR"
}

# Templates directory
TEMPLATES_DIR="$CONFIG_DIR/templates"

# List available templates
list_templates() {
    echo -e "${BOLD}Available templates:${NC}"
    echo

    # Check if templates directory exists and has files
    if [ ! -d "$TEMPLATES_DIR" ] || [ -z "$(ls -A "$TEMPLATES_DIR" 2>/dev/null)" ]; then
        echo -e "  ${DIM}No templates found${NC}"
        echo
        echo -e "  Create one with: ${CYAN}org template new <name>${NC}"
        return
    fi

    for tpl in "$TEMPLATES_DIR"/*.yaml; do
        [ -f "$tpl" ] || continue
        local name=$($BASENAME "$tpl" .yaml)
        local desc=$(head -1 "$tpl" | $SED 's/^# *//')
        printf "  ${CYAN}%-12s${NC} %s\n" "$name" "$desc"
    done
}

# Show template contents
show_template() {
    local name="$1"
    local tpl="$TEMPLATES_DIR/${name}.yaml"

    if [ ! -f "$tpl" ]; then
        echo -e "${RED}Template not found:${NC} $name"
        list_templates
        exit 1
    fi

    echo -e "${BOLD}Template: $name${NC}"
    echo
    grep -v '^#' "$tpl" | grep -v '^$' | while IFS=':' read -r dir desc; do
        dir=$(echo "$dir" | $SED 's/ *$//')
        echo -e "  ${DIM}$dir${NC}"
    done
}

# Create new template
create_template() {
    local name="$1"

    if [ -z "$name" ]; then
        echo -e "${BOLD}Usage:${NC} org template new <name>"
        exit 1
    fi

    local tpl="$TEMPLATES_DIR/${name}.yaml"
    $MKDIR -p "$TEMPLATES_DIR"

    if [ -f "$tpl" ]; then
        echo -e "${YELLOW}Template exists:${NC} $name"
        echo -n "Overwrite? [y/N]: "
        read confirm
        [[ ! "$confirm" =~ ^[Yy] ]] && exit 0
    fi

    # Create template with header and example
    cat > "$tpl" << 'EOF'
# Template name
# Format: Directory: Description
Code: Code and repos
Docs: Documents
EOF

    local editor="${EDITOR:-vim}"
    $editor "$tpl"

    echo -e "${GREEN}Template saved:${NC} $name"
}

# Add a new project path
add_project() {
    require_config
    local input=""
    local template="default"

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -t|--template)
                template="$2"
                shift 2
                ;;
            *)
                input="$1"
                shift
                ;;
        esac
    done

    if [ -z "$input" ]; then
        echo -e "${BOLD}Usage:${NC} org add <path> [-t template]"
        echo
        echo -e "${BOLD}Examples:${NC}"
        echo "  org add YouTube/TechTips -t youtube"
        echo "  org add Clients/Acme"
        echo "  org add SideProjects/MyApp -t default"
        echo
        list_templates
        exit 1
    fi

    # Check template exists
    local tpl="$TEMPLATES_DIR/${template}.yaml"
    if [ ! -f "$tpl" ]; then
        echo -e "${RED}Template not found:${NC} $template"
        list_templates
        exit 1
    fi

    # Generate base alias from path (last component, lowercase)
    local name=$($BASENAME "$input")
    local base_alias=$(echo "$name" | $TR '[:upper:]' '[:lower:]')

    echo -e "${BOLD}Creating:${NC} Work/$input"
    echo -e "${DIM}Template:${NC} $template"
    echo

    # Create parent project directory and config entry
    $MKDIR -p "$BASE_DIR/Work/$input"
    echo "${base_alias}: Work/${input} | ${name}" >> "$CONFIG_FILE"
    echo -e "${GREEN}Created:${NC} Work/$input ${DIM}($base_alias)${NC}"

    # Create subdirectories and add to config from template (yaml format: Dir: Description)
    $GREP -v '^#' "$tpl" | $GREP -v '^$' | while IFS=':' read -r subdir desc; do
        subdir=$(echo "$subdir" | $SED 's/^ *//' | $SED 's/ *$//')
        desc=$(echo "$desc" | $SED 's/^ *//')

        local full_path="Work/$input/$subdir"
        local alias="${base_alias}$(echo "$subdir" | $TR '[:upper:]' '[:lower:]')"

        # Create directory
        $MKDIR -p "$BASE_DIR/$full_path"

        # Add to config
        echo "${alias}: ${full_path} | ${desc}" >> "$CONFIG_FILE"

        echo -e "${GREEN}Created:${NC} $full_path ${DIM}($alias)${NC}"
    done

    # Reload
    load_destinations
}

# Sync config with actual directory structure
sync_config() {
    require_config

    echo -e "${BOLD}Scanning for new directories...${NC}"
    echo

    local found=0

    # Scan Work directories
    if [ -d "$BASE_DIR/Work" ]; then
        $FIND "$BASE_DIR/Work" -type d -mindepth 1 -maxdepth 3 2>/dev/null | while read dir; do
            local rel_path=$(echo "$dir" | $SED "s|$BASE_DIR/||")
            local name=$($BASENAME "$dir")
            local alias=$(echo "$name" | $TR '[:upper:]' '[:lower:]')

            # Check if path already in config
            local exists=0
            for key in "${(k)DESTINATIONS[@]}"; do
                if [ "${DESTINATIONS[$key]}" = "$rel_path" ]; then
                    exists=1
                    break
                fi
            done

            if [ $exists -eq 0 ]; then
                # Check alias collision
                if [ -n "${DESTINATIONS[$alias]}" ]; then
                    alias="${alias}2"
                fi
                echo "${alias}: ${rel_path} | ${name}" >> "$CONFIG_FILE"
                echo -e "${GREEN}Added:${NC} $alias -> $rel_path"
                found=1
            fi
        done
    fi

    # Scan Personal directories
    if [ -d "$BASE_DIR/Personal" ]; then
        $FIND "$BASE_DIR/Personal" -type d -mindepth 2 -maxdepth 3 2>/dev/null | while read dir; do
            local rel_path=$(echo "$dir" | $SED "s|$BASE_DIR/||")
            local name=$($BASENAME "$dir")
            local alias=$(echo "$name" | $TR '[:upper:]' '[:lower:]')

            # Check if path already in config
            local exists=0
            for key in "${(k)DESTINATIONS[@]}"; do
                if [ "${DESTINATIONS[$key]}" = "$rel_path" ]; then
                    exists=1
                    break
                fi
            done

            if [ $exists -eq 0 ]; then
                if [ -n "${DESTINATIONS[$alias]}" ]; then
                    alias="${alias}2"
                fi
                echo "${alias}: ${rel_path} | ${name}" >> "$CONFIG_FILE"
                echo -e "${GREEN}Added:${NC} $alias -> $rel_path"
                found=1
            fi
        done
    fi

    # Reload
    load_destinations
    echo
    echo -e "${GREEN}Sync complete${NC}"
}

# Open code project in editor
open_project() {
    require_config

    # Find all Code directories and list their subdirectories (projects)
    local projects=$($FIND "$BASE_DIR" -type d -name "Code" 2>/dev/null | while read code_dir; do
        $FIND "$code_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null
    done | $SED "s|$BASE_DIR/||")

    if [ -z "$projects" ]; then
        echo -e "${YELLOW}No projects found in Code directories${NC}"
        exit 1
    fi

    local selected=""

    # Use fzf if available, otherwise numbered menu
    if [ -x "$FZF" ]; then
        selected=$(echo "$projects" | $FZF --header="Select project")
    else
        echo -e "${BOLD}Select project:${NC}"
        local i=1
        local project_arr=()
        echo "$projects" | while read p; do
            echo "  $i) $p"
            i=$((i + 1))
        done
        # Store in array
        project_arr=(${(f)projects})
        echo
        echo -n "Choice: "
        read choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#project_arr[@]} ]; then
            selected="${project_arr[$choice]}"
        fi
    fi

    [ -z "$selected" ] && exit 0

    local full_path="$BASE_DIR/$selected"

    # Build editor options
    local editors=()
    local editor_cmds=()

    # Check available editors
    if [ -n "$EDITOR" ]; then
        editors+=("Default (\$EDITOR)")
        editor_cmds+=("$EDITOR")
    fi
    if command -v zed &>/dev/null; then
        editors+=("Zed")
        editor_cmds+=("zed")
    fi
    if command -v cursor &>/dev/null; then
        editors+=("Cursor")
        editor_cmds+=("cursor")
    fi
    if command -v code &>/dev/null; then
        editors+=("VS Code")
        editor_cmds+=("code")
    fi
    if [ -d "/Applications/WebStorm.app" ]; then
        editors+=("WebStorm")
        editor_cmds+=("open -a WebStorm")
    fi
    if [ -d "/Applications/IntelliJ IDEA.app" ]; then
        editors+=("IntelliJ IDEA")
        editor_cmds+=("open -a 'IntelliJ IDEA'")
    fi
    if [ -d "/Applications/PyCharm.app" ]; then
        editors+=("PyCharm")
        editor_cmds+=("open -a PyCharm")
    fi
    if [ -d "/Applications/GoLand.app" ]; then
        editors+=("GoLand")
        editor_cmds+=("open -a GoLand")
    fi

    if [ ${#editors[@]} -eq 0 ]; then
        echo -e "${RED}No editors found${NC}"
        exit 1
    fi

    # If only one editor, use it directly
    if [ ${#editors[@]} -eq 1 ]; then
        eval "${editor_cmds[0]} \"$full_path\""
        echo -e "${GREEN}Opened${NC} $selected ${DIM}in ${editors[0]}${NC}"
        exit 0
    fi

    # Show editor menu
    echo
    echo -e "${BOLD}Open with:${NC}"
    local i
    for i in {0..$((${#editors[@]}-1))}; do
        echo -e "  ${CYAN}$((i+1))${NC}) ${editors[$i]}"
    done
    echo -n "Choice [1]: "
    read choice
    choice=${choice:-1}

    local idx=$((choice-1))
    if [ $idx -ge 0 ] && [ $idx -lt ${#editors[@]} ]; then
        eval "${editor_cmds[$idx]} \"$full_path\""
        echo -e "${GREEN}Opened${NC} $selected ${DIM}in ${editors[$idx]}${NC}"
    else
        echo -e "${RED}Invalid choice${NC}"
        exit 1
    fi
}

# Search for files using fzf and ripgrep (with fallbacks)
search_files() {
    require_config
    local term="$1"
    local selected
    local files

    if [ -z "$term" ]; then
        # No term: list recent files or browse
        files=$($FIND "$BASE_DIR" -type f -not -path "*/.git/*" -not -name ".*" 2>/dev/null | \
            $SED "s|$BASE_DIR/||" | $HEAD -100)
    else
        # With term: search content
        if [ -x "$RG" ]; then
            files=$($RG --files-with-matches --no-messages "$term" "$BASE_DIR" 2>/dev/null | \
                $SED "s|$BASE_DIR/||")
        else
            files=$($GREP -rl "$term" "$BASE_DIR" 2>/dev/null | \
                $SED "s|$BASE_DIR/||")
        fi
    fi

    if [ -z "$files" ]; then
        echo -e "${YELLOW}No files found${NC}"
        exit 0
    fi

    # Use fzf if available, otherwise numbered menu
    if [ -x "$FZF" ]; then
        if [ -z "$term" ]; then
            selected=$(echo "$files" | $FZF \
                --preview "cat '$BASE_DIR/{}' 2>/dev/null | $HEAD -50" \
                --preview-window=right:50% \
                --header="Select file (enter=open)")
        else
            if [ -x "$RG" ]; then
                selected=$(echo "$files" | $FZF \
                    --preview "$RG --color=always -C 3 '$term' '$BASE_DIR/{}' 2>/dev/null" \
                    --preview-window=right:60% \
                    --header="Matches for '$term' (enter=open)")
            else
                selected=$(echo "$files" | $FZF \
                    --preview "$GREP --color=always -C 3 '$term' '$BASE_DIR/{}' 2>/dev/null" \
                    --preview-window=right:60% \
                    --header="Matches for '$term' (enter=open)")
            fi
        fi
    else
        # Fallback: numbered menu
        echo -e "${BOLD}Select file:${NC}"
        local i=1
        local file_arr=(${(f)files})
        for f in "${file_arr[@]}"; do
            echo "  $i) $f"
            i=$((i + 1))
            [ $i -gt 20 ] && echo "  ... (showing first 20)" && break
        done
        echo
        echo -n "Choice (or 'q' to cancel): "
        read choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#file_arr[@]} ]; then
            selected="${file_arr[$choice]}"
        fi
    fi

    if [ -n "$selected" ]; then
        local full_path="$BASE_DIR/$selected"
        echo
        echo -e "Selected: ${CYAN}$selected${NC}"
        echo -e "  ${BOLD}o${NC}) Open  ${BOLD}a${NC}) Archive  ${BOLD}c${NC}) Cancel"
        echo -n "Action [o]: "
        read -k 1 action
        echo
        case "$action" in
            a|A)
                archive_file "$full_path"
                ;;
            c|C|$'\e')
                echo "Cancelled"
                ;;
            *)
                $OPEN "$full_path"
                ;;
        esac
    fi
}

# Remove project directory and config entry
remove_project() {
    require_config
    local alias="$1"

    if [ -z "$alias" ]; then
        echo -e "${BOLD}Usage:${NC} org rm <project>"
        echo
        echo "Removes project directory and all config entries"
        exit 1
    fi

    # Check if alias exists
    if [ -z "${DESTINATIONS[$alias]}" ]; then
        echo -e "${RED}Unknown project: $alias${NC}"
        exit 1
    fi

    local path="${DESTINATIONS[$alias]}"
    local full_path="$BASE_DIR/$path"

    # Count child entries that will be removed
    local child_count=$($GREP -c ": ${path}/" "$CONFIG_FILE" 2>/dev/null || echo "0")

    echo -e "This will ${RED}permanently delete${NC}:"
    echo -e "  Directory: ${CYAN}$full_path${NC}"
    echo -e "  Config entries: ${CYAN}$alias${NC} + ${child_count} subdirectories"
    echo
    echo -n "Are you sure? (y/N) "
    read -k 1 REPLY
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && echo "Cancelled" && exit 0

    # Remove directory
    if [ -d "$full_path" ]; then
        $RM -rf "$full_path"
        echo -e "${GREEN}Removed directory${NC}"
    fi

    # Remove main entry from config
    local tmp_file=$(mktemp)
    $GREP -v "^${alias}:" "$CONFIG_FILE" > "$tmp_file"
    $MV "$tmp_file" "$CONFIG_FILE"

    # Remove all child entries (paths starting with this path/)
    tmp_file=$(mktemp)
    $GREP -v ": ${path}/" "$CONFIG_FILE" > "$tmp_file"
    $MV "$tmp_file" "$CONFIG_FILE"

    echo -e "${GREEN}Removed from config${NC}"

    # Reload
    load_destinations
    echo -e "${GREEN}Config synced${NC}"
}

# Archive entire project
archive_project() {
    require_config
    local alias="$1"

    if [ -z "$alias" ]; then
        echo -e "${BOLD}Usage:${NC} org archive-project <alias>"
        echo
        echo "Archives entire project directory and removes from config"
        exit 1
    fi

    # Check if alias exists
    if [ -z "${DESTINATIONS[$alias]}" ]; then
        echo -e "${RED}Unknown alias: $alias${NC}"
        exit 1
    fi

    local path="${DESTINATIONS[$alias]}"
    local full_path="$BASE_DIR/$path"
    local project_name=$($BASENAME "$full_path")

    if [ ! -d "$full_path" ]; then
        echo -e "${RED}Directory not found: $full_path${NC}"
        exit 1
    fi

    # Determine archive location (work or personal based on path)
    local archive_base=""
    if [[ "$path" == Work/* ]]; then
        if [ -n "${DESTINATIONS[warchive]}" ]; then
            archive_base="$BASE_DIR/${DESTINATIONS[warchive]}"
        else
            archive_base="$BASE_DIR/Work/Archive"
        fi
    else
        if [ -n "${DESTINATIONS[archive]}" ]; then
            archive_base="$BASE_DIR/${DESTINATIONS[archive]}"
        else
            archive_base="$BASE_DIR/Personal/Archive"
        fi
    fi

    local year=$(date +%Y)
    local date_prefix=$(date +%Y-%m-%d)
    local dest_dir="$archive_base/$year"
    local target="$dest_dir/${date_prefix}_${project_name}"

    echo -e "This will archive:"
    echo -e "  From: ${CYAN}$full_path${NC}"
    echo -e "  To:   ${CYAN}$target${NC}"
    echo
    echo -n "Continue? (Y/n) "
    read -k 1 REPLY
    echo
    [[ $REPLY =~ ^[Nn]$ ]] && echo "Cancelled" && exit 0

    # Create archive dir and move
    $MKDIR -p "$dest_dir"
    $MV "$full_path" "$target"
    echo -e "${GREEN}Archived project${NC}"

    # Remove from config
    local tmp_file=$(mktemp)
    $GREP -v "^${alias}:" "$CONFIG_FILE" > "$tmp_file"
    $MV "$tmp_file" "$CONFIG_FILE"
    echo -e "${GREEN}Removed from config${NC}"

    # Also remove any child entries (e.g., project subdirs)
    tmp_file=$(mktemp)
    $GREP -v ": ${path}/" "$CONFIG_FILE" > "$tmp_file"
    $MV "$tmp_file" "$CONFIG_FILE"

    # Reload
    load_destinations
    echo -e "${GREEN}Config synced${NC}"

    local rel_target="${target#$BASE_DIR/}"
    echo -e "\nArchived to: ${CYAN}$rel_target${NC}"
}

# Main command router
case "${1:-}" in
    mv)
        move_file "mv" "$2" "$3"
        ;;
    cp)
        move_file "cp" "$2" "$3"
        ;;
    archive|ar)
        archive_file "$2" "$3"
        ;;
    archive-project|arp)
        archive_project "$2"
        ;;
    rm|remove)
        remove_project "$2"
        ;;
    ls|list)
        list_destinations
        ;;
    cd)
        print_path "$2"
        ;;
    open|o)
        open_dest "$2"
        ;;
    inbox|i)
        process_inbox
        ;;
    status|st)
        show_status
        ;;
    setup)
        setup
        ;;
    create)
        create_dirs
        ;;
    add|new)
        shift
        add_project "$@"
        ;;
    template|tpl)
        case "$2" in
            list|ls|"")
                list_templates
                ;;
            show)
                show_template "$3"
                ;;
            new|create)
                create_template "$3"
                ;;
            edit)
                local tpl="$TEMPLATES_DIR/${3}.yaml"
                if [ -z "$3" ]; then
                    echo -e "${BOLD}Usage:${NC} org template edit <name>"
                    echo
                    list_templates
                elif [ ! -f "$tpl" ]; then
                    echo -e "${RED}Template not found:${NC} $3"
                    list_templates
                else
                    ${EDITOR:-vim} "$tpl"
                fi
                ;;
            *)
                echo -e "${BOLD}Usage:${NC} org template <command>"
                echo
                echo -e "${BOLD}Commands:${NC}"
                echo -e "  ${CYAN}list${NC}         List available templates"
                echo -e "  ${CYAN}show${NC} <name>  Show template structure"
                echo -e "  ${CYAN}edit${NC} <name>  Edit template in \$EDITOR"
                echo -e "  ${CYAN}new${NC} <name>   Create new template"
                ;;
        esac
        ;;
    sync)
        sync_config
        ;;
    edit|config)
        edit_config
        ;;
    find|search|f)
        search_files "$2"
        ;;
    code|projects|p)
        open_project
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        # Try as destination shortcut: org <dest> opens it
        if [ -n "$(match_dest "$1")" ]; then
            open_dest "$1"
        else
            echo -e "${RED}Unknown command: $1${NC}"
            echo "Run ${CYAN}org help${NC} for usage"
            exit 1
        fi
        ;;
esac
