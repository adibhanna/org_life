#!/bin/zsh

# org - Simple file organization CLI
# Usage: org <command> [args]

set -e
setopt KSH_ARRAYS 2>/dev/null || true

# Use full paths for reliability in non-interactive zsh
FIND=/usr/bin/find
WC=/usr/bin/wc
TR=/usr/bin/tr
DU=/usr/bin/du
HEAD=/usr/bin/head
FILE=/usr/bin/file
GREP=/usr/bin/grep
BASENAME=/usr/bin/basename
MKDIR=/bin/mkdir
MV=/bin/mv
CP=/bin/cp
RM=/bin/rm
OPEN=/usr/bin/open
FZF=/opt/homebrew/bin/fzf
RG=/opt/homebrew/bin/rg

# Load config or use defaults
CONFIG_FILE="$HOME/.org_life"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
else
    BASE_DIR="$HOME/Life"
fi

YAML_FILE="$BASE_DIR/org.yaml"

# Default destinations (used if no yaml exists)
DEFAULT_DESTINATIONS="
work: Work
meetings: Work/Meetings
projects: Projects
code: Projects/Code
personal: Projects/Personal
finance: Finance
receipts: Finance/Receipts
taxes: Finance/Taxes
docs: Documents
identity: Documents/Identity
legal: Documents/Legal
media: Media
photos: Media/Photos
screenshots: Media/Screenshots
videos: Media/Videos
designs: Media/Designs
learn: Learning
courses: Learning/Courses
books: Learning/Books
notes: Learning/Notes
archive: Archive
inbox: Inbox
system: System
backups: System/Backups
configs: System/Configs
"

# Load destinations from yaml or use defaults
load_destinations() {
    declare -gA DESTINATIONS
    local yaml_content

    if [ -f "$YAML_FILE" ]; then
        yaml_content=$(cat "$YAML_FILE")
    else
        yaml_content="$DEFAULT_DESTINATIONS"
    fi

    # Parse simple yaml (key: value format)
    while IFS=': ' read -r key value; do
        # Skip empty lines and comments
        [[ -z "$key" || "$key" =~ ^# ]] && continue
        # Clean up whitespace
        key=$(echo "$key" | $TR -d ' ')
        value=$(echo "$value" | sed 's/^ *//')
        [ -n "$key" ] && [ -n "$value" ] && DESTINATIONS[$key]="$value"
    done <<< "$yaml_content"
}

# Load destinations
load_destinations

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

# Get sorted destination keys
get_dest_keys() {
    printf '%s\n' "${(k)DESTINATIONS[@]}" | /usr/bin/sort
}

# Fuzzy match destination
match_dest() {
    local input="$1"
    local exact=""
    local partial=""

    for key in "${(k)DESTINATIONS[@]}"; do
        if [[ "$key" == "$input" ]]; then
            exact="$key"
            break
        elif [[ "$key" == *"$input"* ]]; then
            partial="$key"
        fi
    done

    if [ -n "$exact" ]; then
        echo "$exact"
    elif [ -n "$partial" ]; then
        echo "$partial"
    fi
}

# Show help
show_help() {
    echo -e "${BOLD}org${NC} - Simple file organization CLI"
    echo
    echo -e "${BOLD}USAGE:${NC}"
    echo "  org <command> [args]"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "  ${CYAN}mv${NC} <file> <dest>    Move file to destination"
    echo -e "  ${CYAN}cp${NC} <file> <dest>    Copy file to destination"
    echo -e "  ${CYAN}ls${NC}                  List all destinations"
    echo -e "  ${CYAN}cd${NC} <dest>           Print path (use: cd \$(org cd work))"
    echo -e "  ${CYAN}open${NC} <dest>         Open destination in Finder"
    echo -e "  ${CYAN}inbox${NC}               Process inbox interactively"
    echo -e "  ${CYAN}status${NC}              Show organization status"
    echo -e "  ${CYAN}init${NC}                Create org.yaml config file"
    echo -e "  ${CYAN}create${NC}              Create directories from org.yaml"
    echo -e "  ${CYAN}find${NC} [term]         Search files with fzf (rg for content)"
    echo
    echo -e "${BOLD}DESTINATIONS:${NC}"
    for key in $(get_dest_keys); do
        printf "  ${BLUE}%-12s${NC} %s\n" "$key" "${DESTINATIONS[$key]}"
    done
    echo
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "  org mv invoice.pdf receipts"
    echo "  org mv photo.jpg photos"
    echo "  org open work"
    echo "  org inbox"
}

# Move or copy file to destination
move_file() {
    local action="$1"  # mv or cp
    local file="$2"
    local dest_alias="$3"

    if [ -z "$file" ] || [ -z "$dest_alias" ]; then
        echo -e "${RED}Usage: org $action <file> <destination>${NC}"
        echo -e "Run ${CYAN}org ls${NC} to see available destinations"
        exit 1
    fi

    if [ ! -e "$file" ]; then
        echo -e "${RED}Error: '$file' not found${NC}"
        exit 1
    fi

    # Match destination
    local matched=$(match_dest "$dest_alias")
    if [ -z "$matched" ]; then
        echo -e "${RED}Unknown destination: $dest_alias${NC}"
        echo -e "Run ${CYAN}org ls${NC} to see available destinations"
        exit 1
    fi

    local dest_path="$BASE_DIR/${DESTINATIONS[$matched]}"
    $MKDIR -p "$dest_path"

    # Get filename
    local filename=$($BASENAME "$file")
    local target="$dest_path/$filename"

    # Check for existing file
    if [ -e "$target" ]; then
        echo -e "${YELLOW}File exists: $target${NC}"
        echo -n "Overwrite? (y/N) "
        read -k 1 REPLY
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
    fi

    if [ "$action" = "mv" ]; then
        $MV "$file" "$target"
        echo -e "${GREEN}Moved:${NC} $filename -> ${DESTINATIONS[$matched]}/"
    else
        $CP -r "$file" "$target"
        echo -e "${GREEN}Copied:${NC} $filename -> ${DESTINATIONS[$matched]}/"
    fi
}

# List destinations
list_destinations() {
    echo -e "${BOLD}Available destinations:${NC}"
    echo

    local current_prefix=""
    local key path full_path count prefix

    for key in $(get_dest_keys); do
        path="${DESTINATIONS[$key]}"
        full_path="$BASE_DIR/$path"
        count=0

        if [ -d "$full_path" ]; then
            count=$($FIND "$full_path" -maxdepth 1 -type f 2>/dev/null | $WC -l | $TR -d ' ')
        fi

        # Group by first path component
        prefix="${path%%/*}"
        if [ "$prefix" != "$current_prefix" ]; then
            [ -n "$current_prefix" ] && echo
            current_prefix="$prefix"
        fi

        if [ "$count" -gt 0 ]; then
            printf "  ${BLUE}%-12s${NC} %-25s ${DIM}(%d files)${NC}\n" "$key" "$path" "$count"
        else
            printf "  ${BLUE}%-12s${NC} %s\n" "$key" "$path"
        fi
    done
    echo
    echo -e "${DIM}Base: $BASE_DIR${NC}"
}

# Print path for cd
print_path() {
    local dest_alias="$1"

    if [ -z "$dest_alias" ]; then
        echo "$BASE_DIR"
        return
    fi

    local matched=$(match_dest "$dest_alias")
    if [ -z "$matched" ]; then
        echo "$BASE_DIR"
        return
    fi

    echo "$BASE_DIR/${DESTINATIONS[$matched]}"
}

# Open in Finder
open_dest() {
    local dest_alias="${1:-}"
    local path

    if [ -z "$dest_alias" ]; then
        path="$BASE_DIR"
    else
        local matched=$(match_dest "$dest_alias")
        if [ -z "$matched" ]; then
            echo -e "${RED}Unknown destination: $dest_alias${NC}"
            exit 1
        fi
        path="$BASE_DIR/${DESTINATIONS[$matched]}"
    fi

    $MKDIR -p "$path"
    $OPEN "$path"
    echo -e "${GREEN}Opened:${NC} $path"
}

# Process inbox
process_inbox() {
    local inbox_dir="$BASE_DIR/Inbox"

    if [ ! -d "$inbox_dir" ]; then
        echo -e "${YELLOW}Inbox not found. Run ${CYAN}org init${NC} first.${NC}"
        exit 1
    fi

    # Get files
    local files=()
    while IFS= read -r -d '' file; do
        files+=("$file")
    done < <($FIND "$inbox_dir" -type f -not -name ".*" -print0 2>/dev/null)

    local count=${#files[@]}

    if [ "$count" -eq 0 ]; then
        echo -e "${GREEN}Inbox is empty!${NC}"
        exit 0
    fi

    echo -e "${BOLD}Inbox: $count file(s) to process${NC}"
    echo

    local dest_keys=($(get_dest_keys))

    for file in "${files[@]}"; do
        local filename=$($BASENAME "$file")
        local filesize=$($DU -h "$file" 2>/dev/null | cut -f1)
        local filetype=$($FILE -b "$file" 2>/dev/null | cut -d',' -f1)

        echo -e "${BOLD}File:${NC} ${CYAN}$filename${NC}"
        echo -e "${DIM}Size: $filesize | Type: $filetype${NC}"

        # Preview text files
        if $FILE "$file" | $GREP -q "text"; then
            echo -e "${DIM}Preview:${NC}"
            $HEAD -n 3 "$file" 2>/dev/null | sed 's/^/  /'
        fi
        echo

        echo -e "${BOLD}Move to:${NC}"
        local i=1
        for key in "${dest_keys[@]}"; do
            printf "  ${BLUE}%2d)${NC} %-10s %s\n" "$i" "$key" "${DESTINATIONS[$key]}"
            ((i++))
        done
        echo -e "  ${BLUE} d)${NC} Delete"
        echo -e "  ${BLUE} s)${NC} Skip"
        echo -e "  ${BLUE} q)${NC} Quit"
        echo

        echo -n "Choice: "
        read choice

        case "$choice" in
            [0-9]*)
                if [ "$choice" -ge 1 ] && [ "$choice" -le "${#dest_keys[@]}" ]; then
                    local dest_key="${dest_keys[$((choice-1))]}"
                    local dest_path="$BASE_DIR/${DESTINATIONS[$dest_key]}"
                    $MKDIR -p "$dest_path"
                    $MV "$file" "$dest_path/"
                    echo -e "${GREEN}Moved to ${dest_key}${NC}"
                else
                    echo -e "${YELLOW}Invalid choice, skipping${NC}"
                fi
                ;;
            d|D)
                echo -n "Delete '$filename'? (y/N) "
                read -k 1 REPLY
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    $RM "$file"
                    echo -e "${RED}Deleted${NC}"
                fi
                ;;
            s|S)
                echo -e "${YELLOW}Skipped${NC}"
                ;;
            q|Q)
                echo "Bye!"
                exit 0
                ;;
            *)
                echo -e "${YELLOW}Skipped${NC}"
                ;;
        esac
        echo
    done

    # Final count
    local remaining=$($FIND "$inbox_dir" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
    echo -e "${GREEN}Done!${NC} ${remaining} files remaining in inbox."
}

# Show status
show_status() {
    echo -e "${BOLD}Organization Status${NC}"
    echo

    local inbox_count=0
    local total_size key cat_path cat_count cat_size

    # Inbox count
    if [ -d "$BASE_DIR/Inbox" ]; then
        inbox_count=$($FIND "$BASE_DIR/Inbox" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
    fi

    if [ "$inbox_count" -gt 0 ]; then
        echo -e "${YELLOW}Inbox:${NC} $inbox_count files need sorting"
    else
        echo -e "${GREEN}Inbox:${NC} Empty"
    fi

    # Total size
    if [ -d "$BASE_DIR" ]; then
        total_size=$($DU -sh "$BASE_DIR" 2>/dev/null | cut -f1)
        echo -e "${CYAN}Total:${NC} $total_size"
    fi

    # Recent files
    echo
    echo -e "${BOLD}Recently added:${NC}"
    $FIND "$BASE_DIR" -type f -not -name ".*" -not -path "*/.git/*" -mtime -1 2>/dev/null | $HEAD -5 | while read f; do
        echo "  $($BASENAME "$f")"
    done

    # Category breakdown
    echo
    echo -e "${BOLD}Categories:${NC}"
    for key in work projects finance docs media learn; do
        if [ -n "${DESTINATIONS[$key]}" ]; then
            cat_path="$BASE_DIR/${DESTINATIONS[$key]}"
            if [ -d "$cat_path" ]; then
                cat_count=$($FIND "$cat_path" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
                cat_size=$($DU -sh "$cat_path" 2>/dev/null | cut -f1)
                printf "  %-12s %4d files  %s\n" "$key" "$cat_count" "$cat_size"
            fi
        fi
    done
}

# Create yaml config file
create_yaml() {
    cat > "$YAML_FILE" << 'EOF'
# org.yaml - Directory structure configuration
# Format: alias: path

work: Work
meetings: Work/Meetings

projects: Projects
code: Projects/Code
personal: Projects/Personal

finance: Finance
receipts: Finance/Receipts
taxes: Finance/Taxes

docs: Documents
identity: Documents/Identity
legal: Documents/Legal

media: Media
photos: Media/Photos
screenshots: Media/Screenshots
videos: Media/Videos
designs: Media/Designs

learn: Learning
courses: Learning/Courses
books: Learning/Books
notes: Learning/Notes

archive: Archive
inbox: Inbox

system: System
backups: System/Backups
configs: System/Configs
EOF
    echo -e "${GREEN}Created:${NC} $YAML_FILE"
}

# Initialize config files
init_config() {
    $MKDIR -p "$BASE_DIR"

    if [ -f "$YAML_FILE" ]; then
        echo -e "${YELLOW}Config exists:${NC} $YAML_FILE"
    else
        create_yaml
    fi

    # Create shell config if not exists
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "BASE_DIR=\"$BASE_DIR\"" > "$CONFIG_FILE"
        echo -e "${GREEN}Created:${NC} $CONFIG_FILE"
    fi
}

# Create directories from yaml (or defaults)
create_dirs() {
    # Create yaml if it doesn't exist
    if [ ! -f "$YAML_FILE" ]; then
        $MKDIR -p "$BASE_DIR"
        create_yaml
    fi

    echo -e "${BOLD}Creating directories from $YAML_FILE${NC}"
    echo

    # Reload destinations
    load_destinations

    local key dir_path
    for key in $(get_dest_keys); do
        dir_path="$BASE_DIR/${DESTINATIONS[$key]}"
        if [ ! -d "$dir_path" ]; then
            $MKDIR -p "$dir_path"
            echo -e "${GREEN}Created:${NC} ${DESTINATIONS[$key]}"
        else
            echo -e "${DIM}Exists:${NC} ${DESTINATIONS[$key]}"
        fi
    done

    echo
    echo -e "${GREEN}Done!${NC}"
}

# Search for files using fzf and ripgrep
search_files() {
    local term="$1"
    local selected

    if [ ! -x "$FZF" ]; then
        echo -e "${RED}fzf not found. Install with: brew install fzf${NC}"
        exit 1
    fi

    if [ -z "$term" ]; then
        # No term: interactive file browser
        selected=$($FIND "$BASE_DIR" -type f -not -path "*/.git/*" -not -name ".*" 2>/dev/null | \
            sed "s|$BASE_DIR/||" | \
            $FZF --preview "cat '$BASE_DIR/{}' 2>/dev/null | $HEAD -50" \
                 --preview-window=right:50% \
                 --header="Select file (enter=open, ctrl-c=cancel)")
    else
        # With term: search with ripgrep, select with fzf
        if [ -x "$RG" ]; then
            selected=$($RG --files-with-matches --no-messages "$term" "$BASE_DIR" 2>/dev/null | \
                sed "s|$BASE_DIR/||" | \
                $FZF --preview "$RG --color=always -C 3 '$term' '$BASE_DIR/{}' 2>/dev/null" \
                     --preview-window=right:60% \
                     --header="Matches for '$term' (enter=open)")
        else
            # Fallback if rg not installed
            selected=$($GREP -rl "$term" "$BASE_DIR" 2>/dev/null | \
                sed "s|$BASE_DIR/||" | \
                $FZF --preview "$GREP --color=always -C 3 '$term' '$BASE_DIR/{}' 2>/dev/null" \
                     --preview-window=right:60% \
                     --header="Matches for '$term' (enter=open)")
        fi
    fi

    if [ -n "$selected" ]; then
        $OPEN "$BASE_DIR/$selected"
    fi
}

# Main command router
case "${1:-}" in
    mv)
        move_file "mv" "$2" "$3"
        ;;
    cp)
        move_file "cp" "$2" "$3"
        ;;
    ls|list)
        list_destinations
        ;;
    cd)
        print_path "$2"
        ;;
    open|o)
        open_dest "$2"
        ;;
    inbox|i)
        process_inbox
        ;;
    status|st)
        show_status
        ;;
    init)
        init_config
        ;;
    create)
        create_dirs
        ;;
    find|search|f)
        search_files "$2"
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        # Try as destination shortcut: org <dest> opens it
        if [ -n "$(match_dest "$1")" ]; then
            open_dest "$1"
        else
            echo -e "${RED}Unknown command: $1${NC}"
            echo "Run ${CYAN}org help${NC} for usage"
            exit 1
        fi
        ;;
esac
