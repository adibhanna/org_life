#!/bin/zsh

# org - Simple file organization CLI
# Usage: org <command> [args]

set -e
setopt KSH_ARRAYS 2>/dev/null || true

# Use full paths for reliability in non-interactive zsh
FIND=/usr/bin/find
WC=/usr/bin/wc
TR=/usr/bin/tr
DU=/usr/bin/du
HEAD=/usr/bin/head
FILE=/usr/bin/file
GREP=/usr/bin/grep
BASENAME=/usr/bin/basename
MKDIR=/bin/mkdir
MV=/bin/mv
CP=/bin/cp
RM=/bin/rm
OPEN=/usr/bin/open
SED=/usr/bin/sed
FZF=/opt/homebrew/bin/fzf
RG=/opt/homebrew/bin/rg

# Config file location
CONFIG_FILE="$HOME/.config/org.yaml"
BASE_DIR=""

# Parse base directory from yaml
load_base_dir() {
    if [ ! -f "$CONFIG_FILE" ]; then
        return 1
    fi

    local line
    while IFS= read -r line; do
        if [[ "$line" =~ ^base: ]]; then
            BASE_DIR="${line#base:}"
            BASE_DIR=$(echo "$BASE_DIR" | $SED 's/^ *//' | $SED 's/ *$//')
            BASE_DIR="${BASE_DIR/#\~/$HOME}"
            return 0
        fi
    done < "$CONFIG_FILE"
    return 1
}

# Load base dir on startup
load_base_dir || true

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
DIM='\033[2m'
BOLD='\033[1m'
NC='\033[0m'

# Load destinations from yaml
load_destinations() {
    declare -gA DESTINATIONS
    declare -gA DESCRIPTIONS

    if [ ! -f "$CONFIG_FILE" ]; then
        return 1
    fi

    local key rest path desc

    # Parse yaml (format: key: path | description)
    while IFS= read -r line; do
        # Skip empty lines, comments, and base directive
        [[ -z "$line" || "$line" =~ ^# || "$line" =~ ^base: ]] && continue

        # Extract key (before colon)
        key="${line%%:*}"
        key=$(echo "$key" | $TR -d ' ')
        [[ -z "$key" ]] && continue

        # Extract value (after colon)
        rest="${line#*:}"
        rest=$(echo "$rest" | $SED 's/^ *//')

        # Split by pipe for path and description
        path="${rest%%|*}"
        path=$(echo "$path" | $SED 's/ *$//')

        desc=""
        if [[ "$rest" == *"|"* ]]; then
            desc="${rest#*|}"
            desc=$(echo "$desc" | $SED 's/^ *//')
        fi

        [ -n "$key" ] && [ -n "$path" ] && DESTINATIONS[$key]="$path"
        [ -n "$key" ] && [ -n "$desc" ] && DESCRIPTIONS[$key]="$desc"
    done < "$CONFIG_FILE"
}

# Check if config exists for commands that need it
require_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${YELLOW}No config found.${NC} Run ${CYAN}org setup${NC} first."
        exit 1
    fi
    # Reload base and destinations
    load_base_dir
    load_destinations
}

# Load destinations on startup if config exists
load_destinations || true

# Get sorted destination keys
get_dest_keys() {
    printf '%s\n' "${(k)DESTINATIONS[@]}" | /usr/bin/sort
}

# Fuzzy match destination
match_dest() {
    local input="$1"
    local exact=""
    local partial=""

    for key in "${(k)DESTINATIONS[@]}"; do
        if [[ "$key" == "$input" ]]; then
            exact="$key"
            break
        elif [[ "$key" == *"$input"* ]]; then
            partial="$key"
        fi
    done

    if [ -n "$exact" ]; then
        echo "$exact"
    elif [ -n "$partial" ]; then
        echo "$partial"
    fi
}

# Show help
show_help() {
    echo -e "${BOLD}org${NC} - Simple file organization CLI"
    echo

    # Not configured - show minimal help
    if [ -z "$BASE_DIR" ]; then
        echo -e "Run ${CYAN}org setup${NC} to get started"
        echo
        return
    fi

    # Fully configured - show full help
    echo -e "${BOLD}USAGE:${NC}"
    echo "  org <command> [args]"
    echo
    echo -e "${BOLD}COMMANDS:${NC}"
    echo -e "  ${CYAN}mv${NC} <file> <dest>    Move file to destination"
    echo -e "  ${CYAN}cp${NC} <file> <dest>    Copy file to destination"
    echo -e "  ${CYAN}ls${NC}                  List all destinations"
    echo -e "  ${CYAN}cd${NC} <dest>           Print path (use: cd \$(org cd work))"
    echo -e "  ${CYAN}open${NC} <dest>         Open destination in Finder"
    echo -e "  ${CYAN}inbox${NC}               Process inbox interactively"
    echo -e "  ${CYAN}status${NC}              Show organization status"
    echo -e "  ${CYAN}find${NC} [term]         Search files with fzf (rg for content)"
    echo -e "  ${CYAN}edit${NC}                Edit config in \$EDITOR"
    echo -e "  ${CYAN}create${NC}              Create directories from config"
    echo
    echo -e "${BOLD}DESTINATIONS:${NC}"
    for key in $(get_dest_keys); do
        printf "  ${BLUE}%-12s${NC} %s\n" "$key" "${DESTINATIONS[$key]}"
    done
    echo
    echo -e "${DIM}Config: $CONFIG_FILE${NC}"
}

# Move or copy file to destination
move_file() {
    require_config
    local action="$1"  # mv or cp
    local file="$2"
    local dest_alias="$3"

    if [ -z "$file" ] || [ -z "$dest_alias" ]; then
        echo -e "${RED}Usage: org $action <file> <destination>${NC}"
        echo -e "Run ${CYAN}org ls${NC} to see available destinations"
        exit 1
    fi

    if [ ! -e "$file" ]; then
        echo -e "${RED}Error: '$file' not found${NC}"
        exit 1
    fi

    # Match destination
    local matched=$(match_dest "$dest_alias")
    if [ -z "$matched" ]; then
        echo -e "${RED}Unknown destination: $dest_alias${NC}"
        echo -e "Run ${CYAN}org ls${NC} to see available destinations"
        exit 1
    fi

    local dest_path="$BASE_DIR/${DESTINATIONS[$matched]}"
    $MKDIR -p "$dest_path"

    # Get filename
    local filename=$($BASENAME "$file")
    local target="$dest_path/$filename"

    # Check for existing file
    if [ -e "$target" ]; then
        echo -e "${YELLOW}File exists: $target${NC}"
        echo -n "Overwrite? (y/N) "
        read -k 1 REPLY
        echo
        [[ ! $REPLY =~ ^[Yy]$ ]] && exit 0
    fi

    if [ "$action" = "mv" ]; then
        $MV "$file" "$target"
        echo -e "${GREEN}Moved:${NC} $filename -> ${DESTINATIONS[$matched]}/"
    else
        $CP -r "$file" "$target"
        echo -e "${GREEN}Copied:${NC} $filename -> ${DESTINATIONS[$matched]}/"
    fi
}

# List destinations
list_destinations() {
    require_config

    echo -e "${BOLD}ALIAS        PATH                 DESCRIPTION${NC}"
    echo -e "${DIM}─────────────────────────────────────────────────────────────────${NC}"

    local key path desc

    for key in $(get_dest_keys); do
        path="${DESTINATIONS[$key]}"
        desc="${DESCRIPTIONS[$key]:-}"
        printf "${BLUE}%-12s${NC} %-20s ${DIM}%s${NC}\n" "$key" "$path" "$desc"
    done

    echo
    echo -e "${DIM}Base: $BASE_DIR${NC}"
}

# Print path for cd
print_path() {
    require_config
    local dest_alias="$1"

    if [ -z "$dest_alias" ]; then
        echo "$BASE_DIR"
        return
    fi

    local matched=$(match_dest "$dest_alias")
    if [ -z "$matched" ]; then
        echo "$BASE_DIR"
        return
    fi

    echo "$BASE_DIR/${DESTINATIONS[$matched]}"
}

# Open in Finder
open_dest() {
    require_config
    local dest_alias="${1:-}"
    local path

    if [ -z "$dest_alias" ]; then
        path="$BASE_DIR"
    else
        local matched=$(match_dest "$dest_alias")
        if [ -z "$matched" ]; then
            echo -e "${RED}Unknown destination: $dest_alias${NC}"
            exit 1
        fi
        path="$BASE_DIR/${DESTINATIONS[$matched]}"
    fi

    $MKDIR -p "$path"
    $OPEN "$path"
    echo -e "${GREEN}Opened:${NC} $path"
}

# Process inbox
process_inbox() {
    require_config
    local inbox_dir="$BASE_DIR/Inbox"

    if [ ! -d "$inbox_dir" ]; then
        echo -e "${YELLOW}Inbox not found. Run ${CYAN}org init${NC} first.${NC}"
        exit 1
    fi

    # Get files
    local files=()
    while IFS= read -r -d '' file; do
        files+=("$file")
    done < <($FIND "$inbox_dir" -type f -not -name ".*" -print0 2>/dev/null)

    local count=${#files[@]}

    if [ "$count" -eq 0 ]; then
        echo -e "${GREEN}Inbox is empty!${NC}"
        exit 0
    fi

    echo -e "${BOLD}Inbox: $count file(s) to process${NC}"
    echo

    local dest_keys=($(get_dest_keys))

    for file in "${files[@]}"; do
        local filename=$($BASENAME "$file")
        local filesize=$($DU -h "$file" 2>/dev/null | cut -f1)
        local filetype=$($FILE -b "$file" 2>/dev/null | cut -d',' -f1)

        echo -e "${BOLD}File:${NC} ${CYAN}$filename${NC}"
        echo -e "${DIM}Size: $filesize | Type: $filetype${NC}"

        # Preview text files
        if $FILE "$file" | $GREP -q "text"; then
            echo -e "${DIM}Preview:${NC}"
            $HEAD -n 3 "$file" 2>/dev/null | sed 's/^/  /'
        fi
        echo

        echo -e "${BOLD}Move to:${NC}"
        local i=1
        for key in "${dest_keys[@]}"; do
            printf "  ${BLUE}%2d)${NC} %-10s %s\n" "$i" "$key" "${DESTINATIONS[$key]}"
            ((i++))
        done
        echo -e "  ${BLUE} d)${NC} Delete"
        echo -e "  ${BLUE} s)${NC} Skip"
        echo -e "  ${BLUE} q)${NC} Quit"
        echo

        echo -n "Choice: "
        read choice

        case "$choice" in
            [0-9]*)
                if [ "$choice" -ge 1 ] && [ "$choice" -le "${#dest_keys[@]}" ]; then
                    local dest_key="${dest_keys[$((choice-1))]}"
                    local dest_path="$BASE_DIR/${DESTINATIONS[$dest_key]}"
                    $MKDIR -p "$dest_path"
                    $MV "$file" "$dest_path/"
                    echo -e "${GREEN}Moved to ${dest_key}${NC}"
                else
                    echo -e "${YELLOW}Invalid choice, skipping${NC}"
                fi
                ;;
            d|D)
                echo -n "Delete '$filename'? (y/N) "
                read -k 1 REPLY
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    $RM "$file"
                    echo -e "${RED}Deleted${NC}"
                fi
                ;;
            s|S)
                echo -e "${YELLOW}Skipped${NC}"
                ;;
            q|Q)
                echo "Bye!"
                exit 0
                ;;
            *)
                echo -e "${YELLOW}Skipped${NC}"
                ;;
        esac
        echo
    done

    # Final count
    local remaining=$($FIND "$inbox_dir" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
    echo -e "${GREEN}Done!${NC} ${remaining} files remaining in inbox."
}

# Show status
show_status() {
    require_config
    echo -e "${BOLD}Organization Status${NC}"
    echo

    local inbox_count=0
    local total_size key cat_path cat_count cat_size

    # Inbox count
    if [ -d "$BASE_DIR/Inbox" ]; then
        inbox_count=$($FIND "$BASE_DIR/Inbox" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
    fi

    if [ "$inbox_count" -gt 0 ]; then
        echo -e "${YELLOW}Inbox:${NC} $inbox_count files need sorting"
    else
        echo -e "${GREEN}Inbox:${NC} Empty"
    fi

    # Total size
    if [ -d "$BASE_DIR" ]; then
        total_size=$($DU -sh "$BASE_DIR" 2>/dev/null | cut -f1)
        echo -e "${CYAN}Total:${NC} $total_size"
    fi

    # Recent files
    echo
    echo -e "${BOLD}Recently added:${NC}"
    $FIND "$BASE_DIR" -type f -not -name ".*" -not -path "*/.git/*" -mtime -1 2>/dev/null | $HEAD -5 | while read f; do
        echo "  $($BASENAME "$f")"
    done

    # Category breakdown
    echo
    echo -e "${BOLD}Categories:${NC}"
    for key in work projects finance docs media learn; do
        if [ -n "${DESTINATIONS[$key]}" ]; then
            cat_path="$BASE_DIR/${DESTINATIONS[$key]}"
            if [ -d "$cat_path" ]; then
                cat_count=$($FIND "$cat_path" -type f -not -name ".*" 2>/dev/null | $WC -l | $TR -d ' ')
                cat_size=$($DU -sh "$cat_path" 2>/dev/null | cut -f1)
                printf "  %-12s %4d files  %s\n" "$key" "$cat_count" "$cat_size"
            fi
        fi
    done
}

# Create yaml config file with base directory
create_config() {
    local base_path="$1"
    $MKDIR -p "$HOME/.config"
    cat > "$CONFIG_FILE" << EOF
# org.yaml - File organization config
# Edit with: org edit

base: $base_path

# Format: alias: path | description
work: Work | Work projects and tasks
meetings: Work/Meetings | Meeting notes and agendas

projects: Projects | All projects
code: Projects/Code | Code and development
personal: Projects/Personal | Personal projects

finance: Finance | Financial documents
receipts: Finance/Receipts | Purchase receipts
taxes: Finance/Taxes | Tax documents

docs: Documents | General documents
identity: Documents/Identity | ID, passport, licenses
legal: Documents/Legal | Contracts and legal docs

media: Media | Media files
photos: Media/Photos | Photos and images
screenshots: Media/Screenshots | Screenshots
videos: Media/Videos | Video files
designs: Media/Designs | Design files and assets

learn: Learning | Learning materials
courses: Learning/Courses | Online courses
books: Learning/Books | Ebooks and PDFs
notes: Learning/Notes | Study notes

archive: Archive | Archived files
inbox: Inbox | Files to sort

system: System | System files
backups: System/Backups | Backup files
configs: System/Configs | Config files
EOF
    echo -e "${GREEN}Created:${NC} $CONFIG_FILE"
}

# Setup - create config with base directory
setup() {
    if [ -f "$CONFIG_FILE" ]; then
        echo -e "${YELLOW}Config exists:${NC} $CONFIG_FILE"
        echo -e "Edit with: ${CYAN}org edit${NC}"
        return
    fi

    echo -e "${BOLD}org setup${NC}"
    echo

    # Ask for base directory
    echo -n "Base directory [~/Life]: "
    read base_path
    base_path="${base_path:-~/Life}"
    base_path="${base_path/#\~/$HOME}"

    create_config "$base_path"

    # Reload
    load_base_dir
    load_destinations

    echo
    echo -e "Edit config: ${CYAN}org edit${NC}"
    echo -e "Create dirs: ${CYAN}org create${NC}"
}

# Edit config in $EDITOR
edit_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${YELLOW}No config found.${NC} Run ${CYAN}org setup${NC} first."
        exit 1
    fi

    local editor="${EDITOR:-vim}"
    $editor "$CONFIG_FILE"

    # Reload after edit
    load_base_dir
    load_destinations
}

# Create directories from config
create_dirs() {
    require_config

    echo -e "${BOLD}Creating directories in $BASE_DIR${NC}"
    echo

    local key dir_path
    for key in $(get_dest_keys); do
        dir_path="$BASE_DIR/${DESTINATIONS[$key]}"
        if [ ! -d "$dir_path" ]; then
            $MKDIR -p "$dir_path"
            echo -e "${GREEN}Created:${NC} ${DESTINATIONS[$key]}"
        else
            echo -e "${DIM}Exists:${NC} ${DESTINATIONS[$key]}"
        fi
    done

    echo
    echo -e "${GREEN}Done!${NC} Base: $BASE_DIR"
}

# Search for files using fzf and ripgrep
search_files() {
    require_config
    local term="$1"
    local selected

    if [ ! -x "$FZF" ]; then
        echo -e "${RED}fzf not found. Install with: brew install fzf${NC}"
        exit 1
    fi

    if [ -z "$term" ]; then
        # No term: interactive file browser
        selected=$($FIND "$BASE_DIR" -type f -not -path "*/.git/*" -not -name ".*" 2>/dev/null | \
            sed "s|$BASE_DIR/||" | \
            $FZF --preview "cat '$BASE_DIR/{}' 2>/dev/null | $HEAD -50" \
                 --preview-window=right:50% \
                 --header="Select file (enter=open, ctrl-c=cancel)")
    else
        # With term: search with ripgrep, select with fzf
        if [ -x "$RG" ]; then
            selected=$($RG --files-with-matches --no-messages "$term" "$BASE_DIR" 2>/dev/null | \
                sed "s|$BASE_DIR/||" | \
                $FZF --preview "$RG --color=always -C 3 '$term' '$BASE_DIR/{}' 2>/dev/null" \
                     --preview-window=right:60% \
                     --header="Matches for '$term' (enter=open)")
        else
            # Fallback if rg not installed
            selected=$($GREP -rl "$term" "$BASE_DIR" 2>/dev/null | \
                sed "s|$BASE_DIR/||" | \
                $FZF --preview "$GREP --color=always -C 3 '$term' '$BASE_DIR/{}' 2>/dev/null" \
                     --preview-window=right:60% \
                     --header="Matches for '$term' (enter=open)")
        fi
    fi

    if [ -n "$selected" ]; then
        $OPEN "$BASE_DIR/$selected"
    fi
}

# Main command router
case "${1:-}" in
    mv)
        move_file "mv" "$2" "$3"
        ;;
    cp)
        move_file "cp" "$2" "$3"
        ;;
    ls|list)
        list_destinations
        ;;
    cd)
        print_path "$2"
        ;;
    open|o)
        open_dest "$2"
        ;;
    inbox|i)
        process_inbox
        ;;
    status|st)
        show_status
        ;;
    setup)
        setup
        ;;
    create)
        create_dirs
        ;;
    edit|config)
        edit_config
        ;;
    find|search|f)
        search_files "$2"
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        # Try as destination shortcut: org <dest> opens it
        if [ -n "$(match_dest "$1")" ]; then
            open_dest "$1"
        else
            echo -e "${RED}Unknown command: $1${NC}"
            echo "Run ${CYAN}org help${NC} for usage"
            exit 1
        fi
        ;;
esac
